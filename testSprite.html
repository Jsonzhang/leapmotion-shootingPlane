<!doctype html>
<html>
	<head>	
		<meta charset="utf-8" />
		<!--绘制动画的兼容性方法-->
		<script src="requestNextAnimationFrame.js"></script>
		<!--通用的精灵对象-->
		<script src="Sprite.js"></script>
		<style>
			canvas{border:1px solid red}
		</style>
	</head>
	<body>
		<canvas id="canvas" width="500" height="500">
			当前浏览器不支持canvas元素
		</canvas>
		<script>
			//获取当前页面的canvas绘图环境
			var canvas=document.getElementById('canvas');
			var context=canvas.getContext('2d');
			
			//---------------------------------------------------------------------
			//创建一个精灵绘制器   (描边和填充绘制器 (简单动画) 图像绘制器（背景）)
			//构造方法（该对象的成员属性）
			/**
				url 当前精灵使用的图片
				cells  
			*/
			/*cells=[
				{x:11,y:1,w:1,h:1},
				{x:12,y:1,w:1,h:1},
				{x:21,y:1,w:1,h:1},
				{x:12,y:1,w:1,h:1}
				]
			
			*/
			var SpritePainter=function(url,cells){
				//加载图片
				this.img=new Image();//图片属性对象
				this.img.src=url;//为当前图片的路径
				
				this.cells=cells || [] ;//传入的图像坐标数组(所有图片信息)
				this.cellIndex=0;//当前绘图对象使用的图片信息
			}
			//讲当前对象的方法打入原型当中
			SpritePainter.prototype={
				//更新使用的图片（下标）
				advance:function(){
					if(this.cellIndex==this.cells.length-1){
						//还原图片设置 从第一张图开始使用
						this.cellIndex=0;
					}else{
						//更新图片索引，没有到达最后一张图 索引+1
						this.cellIndex++;
					}
				},
				//图像绘制方法
				paint:function(sprite,context){
					//保证在图片加载完毕的情况下绘制图片
					if(this.img.complete){
						//获取当前绘制使用的图片信息
						var cell=this.cells[this.cellIndex];
						//使用图像信息数组中的某个图片绘制到canvas中
						context.drawImage(this.img,cell.x,cell.y,cell.w,cell.h,sprite.left,sprite.top,cell.w,cell.h);
					}
				}
			}
			
			//新建飞机行为对象
			//飞行行为对象
			//写一个构造方法
			var EnemyFly=function(){
				//用于记录时间的成员属性
				this.lastEnemyFlyTime=0;
			}
			//在圆形中写入方法
			EnemyFly.prototype={
				execute:function(sprite,context,time){
					//检测动画是否开始运行(时间)
					if(this.lastEnemyFlyTime!==0){
						//更新飞机的位置 top坐标
						sprite.top=sprite.top+sprite.moveY/1000*(time-this.lastEnemyFlyTime);
					}
					//记录每次动画的最后一次时间
					this.lastEnemyFlyTime=time;
					
				}
			
			}
			
			//飞机爆炸的行为
			//构造方法
			var EnemyBomb=function(){
				//记录最后一次时间
				this.lastEnemyBombTime=0;
				//每一个画面的时间
				this.cycle=300;
			}
		
			//对象圆形
			EnemyBomb.prototype={
				execute:function(sprite,context,time){
					//轮播每一个图片
					if(time-this.lastEnemyBombTime>this.cycle){
						//更新当前绘图使用的图片
						
						sprite.painter.advance();
						//重新记录最后一次执行时间
						this.lastEnemyBombTime=time;
					}
				
				}
			
			
			}
			
			
			
			//创建飞机对象
			//记录敌机需要使用的图片
			var cells=[
						{x:80,y:655,w:35,h:30},//正常飞机
						{x:45,y:655,w:35,h:30},//中弹爆炸图片
						{x:418,y:731,w:40,h:30},//中弹爆炸图片
						{x:473,y:723,w:40,h:50}//中弹爆炸图片
					];
			
			var Enemy=new Sprite('Enemy',new SpritePainter('gameArts.png',cells),[new EnemyFly(),new EnemyBomb()]);
			//初始化对象的信息
			Enemy.left=100;
			Enemy.top=0;
			//定义飞机飞行速度和位置
			Enemy.moveY=100;//300像素/秒
			
			
			//声明动画回调函数
			function animate(time){
				context.clearRect(0,0,canvas.width,canvas.height);
				//调用更新行为方法
				Enemy.update(context,time);
				//绘制飞机
				Enemy.paint(context);
				//继续调用下一帧的绘制方法
				window.requestNextAnimationFrame(animate);
			}
			
			//调用绘图动画的方法
			window.requestNextAnimationFrame(animate);
			
		</script>
		
	</body>
</html>